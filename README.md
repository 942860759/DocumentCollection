# DocumentCollection
It consists of small CPP
# 一、	开发环境和配置说明（列出开发工具、开发包的名称、版本、特殊配置）
本程序在vs2017下编译运行，对开发工具没有特殊要求，vs系列以及能编译C++的开发工具都可运行，只需要包含<iostream><vector><math.h><cmath>头文件即可。
# 二、	程序的流程和原理
参考网址：http://blog.csdn.net/jsc9410/article/details/51008444
https://wenku.baidu.com/view/1a7b34dfcc1755270622085b.html
 
由于DBSCAN算法是基于密度的算法，对于散点的聚类利用欧氏距离衡量就可以，但轨迹就不同如此。因此必须事先定义轨迹之间的距离。 给定任意的两条线段，其长度及方向不一定相同，如何衡量它们之间的相似度？ 
先从简单的开始，情况一：给定两条同等长度相互平行且两起点的连线或两终点的连线与这两条线段垂直，那么我们可以用它们之间的垂直距离d⊥来衡量它们的相似度，距离越近就越相似，如果这两条线段完全重合就意味着其完全相同。 若在上面的基础上，情况二：将两条线段沿其方向错位或改变其中一条线段的长度，在同等d⊥的情况一和二下，显然它们的相似度只用垂直距离是不够的，需要用水平方向的差别来衡量，即水平距离d∥ 若在情况二的基础上，情况三：将其中一条线段沿某一方向旋转，则两条线段的夹角越大，其相似度越小，因此又需要引入夹角距离dθ的概念。 原文对距离的定义就基于这种思想。 Distance Function 三者的定义如下： d⊥(Li,Lj)=l2⊥1+l2⊥2l⊥1+l⊥2；d∥(Li,Lj)=MIN(l∥1,l∥2)。formula3 第三个公式考虑了轨迹的方向，当夹角大于90度时可视为极不相似，如果不考虑轨迹的方向时，可以用||Lj||×sin(θ) 来衡量。 
将三个部分综合起来就是： SDIST(Li,Lj)=w⊥⋅d⊥(Li,Lj)+w∥⋅d∥(Li,Lj)+wθ⋅dθ(Li,Lj)w⊥，w∥，wθ 分别为三部分的权重。原文中设定权重均为1。SSIM(Li, Lj)=1−Normalized(SDIST(Li, Lj))。
    KNN算法略过，详细部分参考网站，这里只给出相似距离求解原理。
# 三、	程序可调整的参数和说明
const int M = 9;// 全部M个人轨迹
const double w0 = pi / 8;//转角阈值(第一个为pi/7,第二个为pi/6,第三个为pi/8.这个参数影响很大）
const double WD = 0.25, WA = 0.25, WL = 0.5;// 转角、水平方向、垂直方向的权重
const int  KNN = 4;//KNN分类数目
# 四、	程序的输入和输出
    struct Trajectory {
		int n;// 走了n步
		Point point[MAX];}trajectory[M];
	输入满足上诉结构体的数据，输出为聚类结果和相似距离函数
 


